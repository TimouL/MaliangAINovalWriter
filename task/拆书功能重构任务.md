# 拆书功能重构任务

**创建日期：** 2025-11-30  
**状态：** 进行中  
**优先级：** 高

---

## 一、当前架构分析

### 1.1 功能概述

拆书功能用于从番茄小说或用户导入的文本中提取知识（设定、人物、情节等），生成结构化的知识库供后续创作参考。

### 1.2 核心组件

| 组件 | 职责 | 文件位置 |
|------|------|----------|
| `KnowledgeExtractionService` | 对外服务接口 | `service/KnowledgeExtractionService.java` |
| `KnowledgeExtractionServiceImpl` | 服务实现，创建导入记录，提交任务 | `service/impl/KnowledgeExtractionServiceImpl.java` |
| `KnowledgeExtractionTaskExecutor` | 主任务执行器 | `task/executor/KnowledgeExtractionTaskExecutor.java` |
| `KnowledgeExtractionGroupTaskExecutor` | 子任务执行器（按分组提取） | `task/executor/KnowledgeExtractionGroupTaskExecutor.java` |
| `KnowledgeExtractionStrategy` | AI 提取策略 | `service/ai/strategy/KnowledgeExtractionStrategy.java` |
| `FanqieNovelService` | 番茄小说 API 调用 | `service/fanqie/FanqieNovelService.java` |

### 1.3 数据模型

| 模型 | 用途 | 冗余度 |
|------|------|--------|
| `FanqieNovelImportRecord` | 导入记录，跟踪整体状态 | 必要 |
| `KnowledgeExtractionTaskRecord` | 任务详情记录 | 与 BackgroundTask 部分重复 |
| `BackgroundTask` | 通用后台任务 | 必要 |
| `NovelKnowledgeBase` | 知识库结果 | 必要 |
| `UserKnowledgeBaseRelation` | 用户-知识库关系 | 必要 |

### 1.4 当前执行流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              用户发起拆书请求                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ KnowledgeExtractionServiceImpl.extractFromFanqieNovel()                     │
│   1. 查询带 "chaishu" 标签的公共模型配置                                       │
│   2. 创建 FanqieNovelImportRecord (MongoDB 写)                               │
│   3. 提交主任务 KNOWLEDGE_EXTRACTION_FANQIE                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ TaskSubmissionServiceImpl.submitTask()                                      │
│   1. 事务中创建 BackgroundTask (MongoDB 写)                                  │
│   2. 发布 TaskSubmittedEvent                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ KnowledgeExtractionTaskExecutor.execute() [主任务]                          │
│                                                                             │
│   阶段1: 初始化                                                              │
│   ├─ createInitialTaskRecord() (MongoDB 写)                                 │
│   └─ updateProgress()                                                       │
│                                                                             │
│   阶段2: 获取小说内容                                                         │
│   ├─ fanqieNovelService.getNovelDetail() (HTTP)                             │
│   ├─ fanqieNovelService.getChapterList() (HTTP)                             │
│   └─ concatMap: 串行获取前10章内容 (HTTP x 10)                               │
│       └─ fanqieNovelService.getChapterContent() (HTTP)                      │
│                                                                             │
│   阶段3: 更新任务详情                                                         │
│   └─ updateTaskRecordDetails() (MongoDB 写)                                 │
│                                                                             │
│   阶段4: 提取知识 extractKnowledge()                                         │
│   ├─ createExtractionGroups() - 按类型分组 (3-8组)                           │
│   ├─ flatMap(..., 3) 并发创建子任务                                          │
│   │   └─ context.submitSubTask() (MongoDB 写 x N)                           │
│   │                                                                         │
│   └─ waitForAllSubTasksComplete() - 轮询等待                                 │
│       └─ 每5秒: Flux.flatMap 并发查询子任务状态 (MongoDB 读 x N)              │
│                                                                             │
│   阶段5: 聚合结果                                                            │
│   ├─ aggregateResultsAndCreateKnowledgeBase()                               │
│   ├─ knowledgeBaseRepository.save() (MongoDB 写)                            │
│   └─ relationRepository.save() (MongoDB 写)                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    ▼                                   ▼
┌───────────────────────────────┐   ┌───────────────────────────────┐
│ 子任务1: 文风叙事              │   │ 子任务N: 章节大纲              │
│ KnowledgeExtractionGroup      │   │ KnowledgeExtractionGroup      │
│ TaskExecutor.execute()        │   │ TaskExecutor.execute()        │
│                               │   │                               │
│ 1. createProviderByConfigId() │   │ 1. createProviderByConfigId() │
│    ├─ 查询用户配置 (MongoDB)   │   │    ├─ 查询用户配置 (MongoDB)   │
│    ├─ 查询公共配置 (MongoDB)   │   │    ├─ 查询公共配置 (MongoDB)   │
│    └─ 获取API Key (MongoDB)   │   │    └─ 获取API Key (MongoDB)   │
│                               │   │                               │
│ 2. strategy.extractKnowledge  │   │ 2. strategy.extractKnowledge  │
│    ForGroup()                 │   │    ForGroup()                 │
│    └─ 调用外部 LLM API        │   │    └─ 调用外部 LLM API        │
│                               │   │                               │
│ 3. updateSubTaskRecord()      │   │ 3. updateSubTaskRecord()      │
│    (MongoDB 写)               │   │    (MongoDB 写)               │
└───────────────────────────────┘   └───────────────────────────────┘
```

### 1.5 提取类型分组

| 组名 | 包含的提取类型 |
|------|---------------|
| 文风叙事 | NARRATIVE_STYLE, WRITING_STYLE, WORD_USAGE |
| 情节设计 | CORE_CONFLICT, SUSPENSE_DESIGN, STORY_PACING |
| 人物塑造 | CHARACTER_BUILDING |
| 小说特点 | WORLDVIEW, GOLDEN_FINGER |
| 读者情绪 | RESONANCE, PLEASURE_POINT, EXCITEMENT_POINT |
| 热梗搞笑点 | HOT_MEMES, FUNNY_POINTS |
| 用户自定义 | CUSTOM |
| 章节大纲 | CHAPTER_OUTLINE |

---

## 二、已识别的设计缺陷

### 2.1 严重问题

#### 缺陷1：`createProviderByConfigId` 同步阻塞 ✅ 已修复

**问题描述：**
```java
// 修复前 - 在响应式流中使用 .block() 阻塞
public AIModelProvider createProviderByConfigId(String userId, String configId) {
    userAIModelConfigService.getConfigurationById(...).block();  // 阻塞!
    publicModelConfigService.findById(...).block();              // 阻塞!
    publicModelConfigService.getActiveDecryptedApiKey(...).block(); // 阻塞!
}
```

**影响：**
- 阻塞 Reactor 线程，导致连接长时间被占用
- 多个子任务并发时，迅速耗尽线程池
- 其他请求（如管理后台）无法获取数据库连接

**修复方案：** 提交 `e5913f9` 新增 `createProviderByConfigIdAsync` 响应式方法

---

### 2.2 中等问题

#### 缺陷2：子任务轮询机制低效

**问题描述：**
```java
private Mono<List<KnowledgeExtractionGroupResult>> checkAllSubTasksStatus(...) {
    return Flux.fromIterable(subTaskIds)
            .flatMap(taskId -> taskStateService.getTask(taskId)...)  // 并发查询所有子任务
    ...
    return Mono.delay(Duration.ofSeconds(5))
            .flatMap(tick -> checkAllSubTasksStatus(...));  // 每5秒递归轮询
}
```

**影响：**
- 每5秒并发查询 N 个子任务状态（N = 3-8）
- 最多轮询 360 次（30分钟）
- 大量不必要的数据库读操作

**优化方案：** 改为事件驱动通知（见第三部分）

#### 缺陷3：父子任务架构过度设计

**问题描述：**
- 一次拆书被拆分为 1 个主任务 + N 个子任务
- 每个子任务独立存储到 `BackgroundTask` 表
- 主任务需要轮询等待子任务完成
- 子任务之间没有数据依赖，完全可以在主任务内直接处理

**影响：**
- 增加系统复杂度
- 增加数据库操作次数（创建、查询、更新）
- 增加调试和问题排查难度

**优化方案：** 简化为单任务模式（见方案B）

#### 缺陷4：缺乏任务级别并发控制

**问题描述：**
- `taskLocalConcurrency=2000` 允许大量任务并发
- 没有按任务类型区分并发限制
- 拆书任务资源消耗大，不应与普通任务共享并发配额

**影响：**
- 多个拆书任务同时运行会放大所有问题
- 可能影响其他类型任务的执行

**优化方案：** 添加任务类型级别的 Semaphore 限制

---

### 2.3 轻度问题

#### 缺陷5：数据模型冗余

**问题描述：**
- `FanqieNovelImportRecord` 和 `KnowledgeExtractionTaskRecord` 部分字段重复
- `KnowledgeExtractionTaskRecord` 与 `BackgroundTask` 功能重叠

**优化方案：** 合并数据模型，减少冗余记录

#### 缺陷6：章节获取与 AI 处理串行耦合

**问题描述：**
- 章节获取在主任务中同步进行
- AI 处理在子任务中进行
- 整个流程串行依赖

**优化方案：** 可以考虑流水线处理，但优先级较低

---

## 三、重构方案

### 方案A：最小改动 - 修复关键阻塞点 (短期)

**目标：** 快速修复导致系统不可用的严重问题

**实施内容：**

1. ✅ **将 `createProviderByConfigId` 改为响应式方法**
   - 新增 `createProviderByConfigIdAsync` 方法
   - 修改 `KnowledgeExtractionGroupTaskExecutor` 使用新方法
   - 状态：已完成

2. ⏳ **子任务轮询改为事件驱动通知**
   ```java
   // 修改前：轮询
   return Mono.delay(Duration.ofSeconds(5))
           .flatMap(tick -> checkAllSubTasksStatus(...));
   
   // 修改后：事件驱动
   // 子任务完成时发布事件，主任务订阅事件
   public class SubTaskCompletedEvent {
       String parentTaskId;
       String subTaskId;
       TaskStatus status;
       Object result;
   }
   ```

3. ⏳ **添加拆书任务并发限制**
   ```java
   // 在 KnowledgeExtractionTaskExecutor 中添加
   private static final Semaphore EXTRACTION_SEMAPHORE = new Semaphore(5); // 最多5个并发
   
   @Override
   public Mono<KnowledgeExtractionResult> execute(TaskContext<...> context) {
       return Mono.fromCallable(() -> EXTRACTION_SEMAPHORE.acquire())
               .then(doExecute(context))
               .doFinally(signal -> EXTRACTION_SEMAPHORE.release());
   }
   ```

**预期效果：**
- 解决连接阻塞问题
- 减少数据库轮询压力
- 控制并发避免资源耗尽

---

### 方案B：简化架构 - 去掉子任务机制 (中期)

**目标：** 简化系统架构，减少复杂度和数据库操作

**核心改动：**

1. **取消子任务设计**
   - 主任务内直接串行/有限并发执行所有 AI 调用
   - 使用 `Flux.concatMap` 或 `Flux.flatMap(..., 2)` 控制并发
   
   ```java
   // 修改后的 extractKnowledge
   private Mono<KnowledgeExtractionResult> extractKnowledge(...) {
       List<ExtractionGroup> groups = createExtractionGroups(extractionTypes);
       
       return Flux.fromIterable(groups)
               .concatMap(group -> extractSingleGroup(group, content, parameters))  // 串行执行
               .collectList()
               .flatMap(results -> aggregateResults(results, contentData, parameters));
   }
   
   private Mono<KnowledgeExtractionGroupResult> extractSingleGroup(...) {
       return aiService.createProviderByConfigIdAsync(userId, configId)
               .flatMap(provider -> {
                   KnowledgeExtractionStrategy strategy = new KnowledgeExtractionStrategy(provider, objectMapper);
                   return strategy.extractKnowledgeForGroup(...);
               })
               .map(settings -> KnowledgeExtractionGroupResult.builder()
                       .groupName(group.getName())
                       .settings(settings)
                       .success(true)
                       .build());
   }
   ```

2. **简化数据模型**
   - 移除 `KnowledgeExtractionTaskRecord`，使用 `BackgroundTask.progress` 存储详情
   - 或者反过来，只保留 `KnowledgeExtractionTaskRecord`，不创建 `BackgroundTask` 子任务

3. **简化进度更新**
   - 进度直接在主任务中更新
   - 不需要子任务状态同步

**预期效果：**
- 代码复杂度降低 50%
- 数据库操作减少 60%
- 问题排查更简单

**迁移策略：**
- 保留现有接口不变
- 内部实现重构
- 旧任务继续按旧逻辑执行（通过 taskType 区分）

---

### 方案C：彻底重构 - 基于事件的流水线 (长期)

**目标：** 支持更复杂的场景，如失败重试、部分成功、断点续传

**核心设计：**

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 章节获取     │───▶│ AI 提取     │───▶│ 结果聚合    │───▶│ 知识库创建   │
│ Stage       │    │ Stage       │    │ Stage       │    │ Stage       │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
      │                  │                  │                  │
      ▼                  ▼                  ▼                  ▼
  ChapterEvent      ExtractEvent      AggregateEvent    CompleteEvent
```

**关键组件：**
- `KnowledgeExtractionPipeline` - 流水线协调器
- `ChapterFetchStage` - 章节获取阶段
- `AIExtractionStage` - AI 提取阶段
- `AggregationStage` - 结果聚合阶段
- `PersistenceStage` - 持久化阶段

**特性：**
- 每个阶段独立，可单独重试
- 支持断点续传（章节获取失败后可继续）
- 支持部分成功（部分分组提取失败不影响整体）
- 更好的可观测性（每个阶段独立监控）

**适用场景：**
- 需要处理大型小说（上千章节）
- 需要支持多种 AI 模型切换
- 需要更精细的错误处理

---

## 四、实施计划

### 阶段1：紧急修复 (1-2天)

| 任务 | 状态 | 说明 |
|------|------|------|
| 修复 `createProviderByConfigId` 阻塞 | ✅ 完成 | 新增响应式方法 |
| 修改 `KnowledgeExtractionGroupTaskExecutor` | ✅ 完成 | 使用新方法 |
| 编译验证 | ✅ 完成 | 无错误 |
| 提交代码 | ⏳ 待做 | - |
| 部署测试 | ⏳ 待做 | 验证拆书功能正常 |

### 阶段2：优化改进 (3-5天)

| 任务 | 状态 | 说明 |
|------|------|------|
| 实现子任务完成事件通知 | ⏳ 待做 | 替代轮询机制 |
| 添加拆书任务并发限制 | ⏳ 待做 | Semaphore 控制 |
| 优化子任务状态查询 | ⏳ 待做 | 批量查询替代逐个查询 |

### 阶段3：架构简化 (1-2周)

| 任务 | 状态 | 说明 |
|------|------|------|
| 设计单任务模式方案 | ⏳ 待做 | 详细设计文档 |
| 实现新版 `extractKnowledge` | ⏳ 待做 | 去掉子任务 |
| 简化数据模型 | ⏳ 待做 | 合并/删除冗余表 |
| 兼容性测试 | ⏳ 待做 | 确保旧任务正常 |
| 迁移旧数据 | ⏳ 待做 | 如需要 |

---

## 五、相关文件清单

### 核心文件

```
AINovalServer/src/main/java/com/ainovel/server/
├── service/
│   ├── AIService.java                              # AI 服务接口
│   ├── KnowledgeExtractionService.java             # 知识提取服务接口
│   ├── impl/
│   │   ├── AIServiceImpl.java                      # AI 服务实现 ⚠️ 已修改
│   │   └── KnowledgeExtractionServiceImpl.java     # 知识提取服务实现
│   └── ai/
│       └── strategy/
│           └── KnowledgeExtractionStrategy.java    # AI 提取策略
├── task/
│   ├── executor/
│   │   ├── KnowledgeExtractionTaskExecutor.java    # 主任务执行器
│   │   └── KnowledgeExtractionGroupTaskExecutor.java # 子任务执行器 ⚠️ 已修改
│   └── service/
│       ├── TaskStateService.java                   # 任务状态服务
│       ├── TaskSubmissionService.java              # 任务提交服务
│       └── impl/
│           ├── TaskStateServiceImpl.java
│           └── TaskSubmissionServiceImpl.java
├── domain/model/
│   ├── FanqieNovelImportRecord.java               # 导入记录
│   ├── KnowledgeExtractionTaskRecord.java         # 任务记录
│   ├── NovelKnowledgeBase.java                    # 知识库
│   └── BackgroundTask.java                        # 通用任务
└── repository/
    ├── FanqieNovelImportRecordRepository.java
    ├── KnowledgeExtractionTaskRecordRepository.java
    ├── NovelKnowledgeBaseRepository.java
    └── BackgroundTaskRepository.java
```

### 配置文件

```
AINovalServer/src/main/resources/
└── application.yml
    # 相关配置项：
    # - spring.data.mongodb.* (MongoDB 连接池)
    # - task.local.concurrency (任务并发数)
```

---

## 六、监控和告警

### 建议添加的监控指标

1. **拆书任务指标**
   - 同时运行的拆书任务数
   - 单任务平均执行时间
   - 子任务完成率
   - AI 调用成功率

2. **数据库连接指标**
   - 连接池使用率
   - 连接等待时间
   - 连接超时次数

3. **告警规则**
   - 连接等待时间 > 5秒
   - 拆书任务失败率 > 10%
   - 同时运行拆书任务 > 10

---

## 七、回滚方案

如果新代码出现问题，可以通过以下方式回滚：

1. **方案A 回滚**
   - `createProviderByConfigIdAsync` 仍调用同步方法
   - 风险低，同步方法仍保留

2. **方案B 回滚**
   - 通过任务类型区分新旧逻辑
   - 新任务使用新类型，旧任务继续使用旧逻辑
   - 回滚时禁用新任务类型即可

---

## 八、更新日志

| 日期 | 内容 | 提交 |
|------|------|------|
| 2025-11-30 | 创建文档，完成架构分析 | - |
| 2025-11-30 | 修复 `createProviderByConfigId` 阻塞问题 | 待提交 |
